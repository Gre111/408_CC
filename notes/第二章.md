# 第二章

进制计算

十进制->二进制    二进制->十进制

基数：每个数码所用到的不同符号的个数，r进制基数为r

**BCD（Binary-Coded Decimal**

- 8421码：数字表示权重

- 余3码：8421码 + （0011

- 2421码：从左到右权重为2421

三种编码

原码：

- 机器字长n+1位，带符号整数的原码表示范围：$-(2^n-1)\le x\le 2^n-1$

- 真值0有两种形式：+0和-0，$[+0]_原=0,0000000;[-0]_原=1,0000000$

注：真值是人使用的数

反码：

- 对正数而言，其反码等于原码

- 对负数来说，将原码的数值位取反得到反码，符号位不变

补码：

- 对正数而言，其补码=反码=原码

- 对负数来说，将反码末位+1得到补码

- 机器字长n+1位，补码表示范围：$-2^n\le x\le 2^n-1$

- 只有一个0，1,0000000是$-2^7$

- 优势：符号位参与运算，利于计算机实现

移码：

- 将补码的符号位取反就是移码

- 能直观看出大小，方便用硬件电路对比大小

<mark>原码<——>补码の快速转换</mark>：从右向左找到第一个1，把它左边的 全部 数据位 取反即可

计算机对<mark>带符号数</mark>的计算建立在补码基础上，将减法化为加法，把补码相加扔掉溢出位，得到结果的<mark>补码</mark>

    +18——>00010010

    -19——>11101101

+

————————————

        -1——11111111

---

补码减法运算：减法化加法

$$
A-B=A+(-B)<-->[A]_补-[B]_补=[A]_补+[-B]_补
$$

思路很好理解，算A-B就是算A+(-B)，用加法规则：补码相加

奇技淫巧之正负补码间的转换：全部位按位取反，末位+1（硬件实现的基础理论

**Q&A：**

1. 无符号数怎么计算？
   
   - 无符号数也有原、反、补码一说，需要注意的是减法，把减数<mark>所有位</mark>取反，末位+1，然后与被减数相加得到结果的补码（注意没有负数表示，即补码肯定等于原码）。

2. 

**引入定点小数**

整数可以看成小数点在末尾如 $1D=0,000 0001.$

而定点小数的小数点则是位于符号位后，一般记为$-0.25D=1.100 0000$

定点小数的原、反、补码变换规则、加减法和整数一样

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-17-18-06-09-image.png" alt="" data-align="center" width="589">

~~看看这哥们能看几页书：51页    14:40~~

**奇偶校验**（只能检验奇数个bit错误

往数据开头添加一个校验bit位

奇校验：

- 使得整体数据中1的个数为奇数个

- 发送前全部位 异或 后得到结果为1，若检验时异或结果为0则发生错误

偶校验：

- 使数据中1的个数为偶数个

- 发送前全部位 异或 后得到结果为0，若检验时异或结果为 1 则发生错误

---

运算的硬件电路实现~~

补码加减的实现：

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-18-16-40-13-image.png" alt="" data-align="center" width="431">

**溢出判断的三种方法**

方法1：采用一位符号位

$$
A_S、B_S、S_S分别表示被加数、加数、和的符号位
$$

- 记$V=A_SB_S\overline{S_S}+\overline{A_SB_S}S_S$，若V=0则无溢出，若V=1则有溢出

方法2：进位表示法

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-18-18-00-32-image.png" alt="" data-align="left" width="259">

- 符号位的进位为$C_S$，最高数值位的进位$C_1$

- |     | $C_S$ | $C_1$ |
  |:---:|:-----:|:-----:|
  | 上溢  | 0     | 1     |
  | 下溢  | 1     | 0     |

方法3：双符号位（存储时只存1位，运算时复制一位

- 正数符号为00，负数符号为11

- 两数相加，记$V=S_{S1}\oplus S_{S2}$，V=0表示无溢出，V=1表示有溢出

- $00+00=01$表示上溢，$11+11=10$表示下溢 

---

**标志位**

OF：溢出标志位，将结果最高位、次高位产生的进位异或，为1则溢出。（only有符号数

SF：最高位的本位之和（包括进位），为0表示正数（only signed number

ZF：运算结果，为0表示结果为零

CF：进/借位标志，最高位产生的进位与sub异或，为1表示发生进位或借位（only unsigned number

Q&A：

1. sub位是啥？
   
   - 控制信号；做减法时要把减数变负数，全部按位取反后加一，1就是sub。而对做加法来说，sub就是0。

**移位运算**

值得关注的是带进位位的循环移位，CF位参与到移位，为高字节提供进位

**原码的乘法运算**

- 手算和十进制过程一样

- 机器实现：原码一位乘法，关键点有三
  
  1. ✨在运算器中使用加法和移位模拟乘法（其实也不算，因为这就是本质）；初始ACC的内容为0，用乘数的末位乘以被乘数后加到结果上再把ACC和MQ统一逻辑右移一位，既实现了错位相加又顺便把乘过的末位挤走
  
  2. 修改积的符号位，$X_s\oplus X_y$
  
  3. 注意积的位数~~一般~~是两乘数位数之和，故存中间结果时同时用到了ACC和MQ的寄存器

- 手算模拟 机器的实现也要会（惨~），容易迷惑的点是模拟逻辑右移时符号位也要一起移动，因为在中间结果中不存在正负一说，符号位只是拓展计算结果用的

**补码的一位乘法**

淦，只能硬记了，补码乘法在我看来没什么“原生感性点”，只是把规律冷硬地逻辑拼接（为甚么要记这个啊？

什么需要双符号位，什么逻辑右移（符号位不动），什么每次加上的数有三种情况：+0、$+[x]_补$、$+[-x]_补$

$$
1.辅助位-MQ“最低位”=1时，(ACC)+[x]_补\\
$$

$$
2.辅助位-MQ“最低位”=0时，(ACC)+0\\
$$

$$
3.辅助位-MQ“最低位”=-1时，(ACC)+[-x]_补\\
$$

崩溃了啊😩

---

**原码除法**

机器实现：恢复余数法

- ACC存放被除数、余数，x通用寄存器存除数，MQ存商，<mark>带符号位计算</mark>（因为用到减法

- ACC和MQ串联，计算开始时根据被除数和除数的大小关系确定商（*实际对计算机而言……见最后一条*）置于MQ末位，然后整体逻辑左移——模拟将余数乘以2且把未定商往左移一位，循环下去

- 根据商的长度是否达到机器字长判断应不应该结束计算

- 注：（实际对计算机而言商的默认值是1，通过被除数与除数相减的结果——也就是余数的正负判断置1是不是正确，如果错了就还原即加上除数得到原先的被除数，且把1换成正确结果0）这也是名字的由来
