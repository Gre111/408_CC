# 第二章

进制计算

十进制->二进制    二进制->十进制

基数：每个数码所用到的不同符号的个数，r进制基数为r

**BCD（Binary-Coded Decimal**

- 8421码：数字表示权重

- 余3码：8421码 + （0011

- 2421码：从左到右权重为2421

三种编码

原码：

- 机器字长n+1位，带符号整数的原码表示范围：$-(2^n-1)\le x\le 2^n-1$

- 真值0有两种形式：+0和-0，$[+0]_原=0,0000000;[-0]_原=1,0000000$

注：真值是人使用的数

反码：

- 对正数而言，其反码等于原码

- 对负数来说，将原码的数值位取反得到反码，符号位不变

补码：

- 对正数而言，其补码=反码=原码

- 对负数来说，将反码末位+1得到补码

- 机器字长n+1位，补码表示范围：$-2^n\le x\le 2^n-1$

- 只有一个0，1,0000000是$-2^7$

- 优势：符号位参与运算，利于计算机实现

移码：

- 将补码的符号位取反就是移码

- 能直观看出大小，方便用硬件电路对比大小

<mark>原码<——>补码の快速转换</mark>：从右向左找到第一个1，把它左边的 全部 数据位 取反即可

计算机对<mark>带符号数</mark>的计算建立在补码基础上，将减法化为加法，把补码相加扔掉溢出位，得到结果的<mark>补码</mark>

    +18——>00010010

    -19——>11101101

+

————————————

        -1——11111111

---

补码减法运算：减法化加法

$$
A-B=A+(-B)<-->[A]_补-[B]_补=[A]_补+[-B]_补
$$

思路很好理解，算A-B就是算A+(-B)，用加法规则：补码相加

奇技淫巧之正负补码间的转换：全部位按位取反，末位+1（硬件实现的基础理论

**Q&A：**

1. 无符号数怎么计算？
   
   - 无符号数也有原、反、补码一说，需要注意的是减法，把减数<mark>所有位</mark>取反，末位+1，然后与被减数相加得到结果的补码（注意没有负数表示，即补码肯定等于原码）。

2. 

**引入定点小数**

整数可以看成小数点在末尾如 $1D=0,000 0001.$

而定点小数的小数点则是位于符号位后，一般记为$-0.25D=1.100 0000$

定点小数的原、反、补码变换规则、加减法和整数一样

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-17-18-06-09-image.png" alt="" data-align="center" width="589">

~~看看这哥们能看几页书：51页    14:40~~

**奇偶校验**（只能检验奇数个bit错误

往数据开头添加一个校验bit位

奇校验：

- 使得整体数据中1的个数为奇数个

- 发送前全部位 异或 后得到结果为1，若检验时异或结果为0则发生错误

偶校验：

- 使数据中1的个数为偶数个

- 发送前全部位 异或 后得到结果为0，若检验时异或结果为 1 则发生错误

---

运算的硬件电路实现~~

补码加减的实现：

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-18-16-40-13-image.png" alt="" data-align="center" width="431">

**溢出判断的三种方法**

方法1：采用一位符号位

$$
A_S、B_S、S_S分别表示被加数、加数、和的符号位
$$

- 记$V=A_SB_S\overline{S_S}+\overline{A_SB_S}S_S$，若V=0则无溢出，若V=1则有溢出

方法2：进位表示法

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-18-18-00-32-image.png" alt="" data-align="left" width="259">

- 符号位的进位为$C_S$，最高数值位的进位$C_1$

- |     | $C_S$ | $C_1$ |
  |:---:|:-----:|:-----:|
  | 上溢  | 0     | 1     |
  | 下溢  | 1     | 0     |

方法3：双符号位（存储时只存1位，运算时复制一位

- 正数符号为00，负数符号为11

- 两数相加，记$V=S_{S1}\oplus S_{S2}$，V=0表示无溢出，V=1表示有溢出

- $00+00=01$表示上溢，$11+11=10$表示下溢 

---

**标志位**

OF：溢出标志位，将结果最高位、次高位产生的进位异或，为1则溢出。（only有符号数

SF：最高位的本位之和（包括进位），为0表示正数（only signed number

ZF：运算结果，为0表示结果为零

CF：进/借位标志，最高位产生的进位与sub异或，为1表示发生进位或借位（only unsigned number

Q&A：

1. sub位是啥？
   
   - 控制信号；做减法时要把减数变负数，全部按位取反后加一，1就是sub。而对做加法来说，sub就是0。

---

**移位运算**

值得关注的是带进位位的循环移位，CF位参与到移位，为高字节提供进位

**原码的乘法运算**

- 手算和十进制过程一样

- 机器实现：原码一位乘法，关键点有三
  
  1. ✨在运算器中使用加法和移位模拟乘法（其实也不算，因为这就是本质）；初始ACC的内容为0，用乘数的末位乘以被乘数后加到结果上再把ACC和MQ统一逻辑右移一位，既实现了错位相加又顺便把乘过的末位挤走
  
  2. 修改积的符号位，$X_s\oplus X_y$
  
  3. 注意积的位数~~一般~~是两乘数位数之和，故存中间结果时同时用到了ACC和MQ的寄存器

- 手算模拟 机器的实现也要会（惨~），容易迷惑的点是模拟逻辑右移时符号位也要一起移动，因为在中间结果中不存在正负一说，符号位只是拓展计算结果用的

**补码的一位乘法**

淦，只能硬记了，补码乘法在我看来没什么“原生感性点”，只是把规律冷硬地逻辑拼接（为甚么要记这个啊？

什么需要双符号位，什么逻辑右移（符号位不动），什么每次加上的数有三种情况：+0、$+[x]_补$、$+[-x]_补$

$$
1.辅助位-MQ“最低位”=1时，(ACC)+[x]_补\\
$$

$$
2.辅助位-MQ“最低位”=0时，(ACC)+0\\
$$

$$
3.辅助位-MQ“最低位”=-1时，(ACC)+[-x]_补\\
$$

崩溃了啊😩

---

**定点小数原码除法**

1.恢复余数法

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-20-22-51-56-image.png" alt="" width="383" data-align="center">

- ACC存放被除数、余数，x通用寄存器存除数，MQ存商，<mark>带符号位计算</mark>（因为用到减法

- ACC和MQ串联，计算开始时根据被除数和除数的大小关系确定商（*实际对计算机而言……见最后一条*）置于MQ末位，然后整体逻辑左移——模拟将余数乘以2且把未定商往左移一位，循环下去

- 根据商的长度是否达到机器字长判断应不应该结束计算

- 最后余数为负数的话需要恢复余数，最后结果不能为负

- 注：（实际对计算机而言商的默认值是1，通过被除数与除数相减的结果——也就是余数的正负判断置1是不是正确，如果错了就还原即加上除数得到原先的被除数，且把1换成正确结果0）这也是名字的由来

也要学手算过程，还好吧

2.优化的恢复余数法（加减交替法

省掉发现余数为负然后恢复余数的步骤。由运算公式的推理可知，假设余数a位负，除数为b，则从“恢复到左移再到减除数”的步骤化简为$2a+b$，既然如此何不一步到位？即碰到余数为负直接左移再加除数。

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-20-22-51-14-image.png" alt="" data-align="center" width="427">

**补码除法**（不恢复余数法

以10进制为例，探明余数与除数同异号对算法影响的原因

![](C:\Users\jia'le\AppData\Roaming\marktext\images\2024-07-21-19-31-37-image.png)

![](C:\Users\jia'le\AppData\Roaming\marktext\images\2024-07-21-19-31-18-image.png)

判断够不够减要根据中间余数与除数符号的关系

- 相同符号：同号够减、异号不够减

- 不同符号：异号够减、同号不够减

求商值

- 若$[X]_补$与$[Y]_补$同号，则商为正，“够减”时上商1，不够减时上商0（按原码规则上商）

- 若$[X]_补$与$[Y]_补$异号，则商为负，“够减”时上商0，不够减时上商1（按反码规则上商）

<img src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-21-19-13-47-image.png" title="" alt="" data-align="center">

或者用王道给的结论

![](C:\Users\jia'le\AppData\Roaming\marktext\images\2024-07-21-20-06-01-image.png)

**C语言类型转换**

1. 同长度有符号转换为无符号数，只改变解释方式。如
   
   ```c
   short x = -4321;                        //x为1110 1111 0001 1111
   unsigned short y = (unsigned short)x;   //y被解释为整数
   ```

2. 长整型转换为短整型，直接截断。如
   
   ```c
   int a=165537, b= -34991;        //a:0002 86a1 c:ffff 7751
   short c =(short)a, d=(short)b;  //c:86a1      d:7751
   ```

3. 短整型转换为长整型，宽展符号位。如
   
   ```c
   short x= -4321;    //x:1110 1111 0001 1111
   int m = x;         //m:1111 1111 1111 1111 1110 1111 0001 1111
   unsigned short n=(unsigned short)x;//n:1110 1111 0001 1111
   unsigned int p=n;  //p:0000 0000 0000 0000 1110 1111 0001 1111
   ```

**数据存储**

大端存储：高字节存到高地址

小端存储：高字节存到低地址



#### 浮点数

浮点数由阶码和尾数组成（类似科学计数法

- 阶码：常用补码或移码表示的<mark>定点整数</mark>，用符号E表示，反映浮点数的表示范围及小数点的实际位置

- 尾数：常用原码或补码表示的<mark>定点小数</mark>，用符号M表示，反映浮点数的精度

浮点数的真值$N=r^EM$，r表示基底，通常为2

`example: a=0,01;1.1001`  $a=2^1(-0.1001)$

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-22-16-07-32-image.png" alt="" data-align="center" width="494">

**尾数的规格化**

左规：使尾数最高位是有效值（指数值部分），为此可把尾数算术左移n位，阶码减n

目的是解决空间不够存的问题（用精度换空间

<img src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-22-16-14-16-image.png" title="" alt="" width="324">



右规：尾数算数右移n位，阶码加n

可能的应用：采用双符号位的浮点数相加导致尾数溢出时，可以右规挽救

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-22-16-18-18-image.png" alt="" width="489">



规格化后的浮点数表示范围有正数区和负数区两块，绝对值靠近0、趋于无穷的数都无法表示

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-22-16-37-46-image.png" alt="" data-align="center" width="407">

`attention`上面提到的浮点数都是原码表示，而<mark>补码</mark>表示有些特殊规定

1. 尾数规格化
   
   - 正数为0.1XX...X的形式，其最大值表示为0.11...1；最小表示为0.10...0
   
   - 负数为1.0XX...X的形式，最大1.01...1；最小1.00...0



**IEEE 754标准**

该标准中只有一个符号位$m_s$表示浮点数正负，阶码用移码表示，尾数数值位用原码表示（省略了最高位1），实际为1.M

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-22-17-43-45-image.png" alt="" data-align="center" width="528">

| 类型       | 数符  | 阶码  | 尾数数值 | 总位数 | 偏置值  |
|:--------:|:---:|:---:|:----:|:---:|:----:|
| `float`  | 1   | 8   | 23   | 32  | 127  |
| `double` | 1   | 11  | 52   | 64  | 1023 |



规格化的短浮点数的真值为：$(-1)^s*1.M*2^{E-127}$

规格化的长浮点数的真值为：$(-1)^s*1.M*2^{E-1023}$

| 格式  | 规格化的最小绝对值           | 规格化的最大绝对值               |
|:---:|:-------------------:|:-----------------------:|
| 单精度 | $(1.0)_2*2^{-126}$  | $(1.11...1)_2*2^{127}$  |
| 双精度 | $(1.0)_2*2^{-1022}$ | $(1.11...1)_2*2^{1023}$ |

如果要表示的数比最小值还小怎么办？（可以试试非规格化小数

阶码的`全0：-127`和`全1：-128`用作特殊用途

- 当阶码E全0，尾数M不全为0时，表示<mark>非规格化小数</mark>$\pm(0.xx...x)_2*2^{-126}$

- 当阶码全0，尾数全0时，表示真值$\pm0$

- 当阶码全1，尾数全0时，表示无穷大$\pm\infty$

- 当阶码全1，尾数不全为0时，表示非数值“NaN”



**浮点数运算**

步骤如下：

1对阶    2尾数加减    3规格化    4舍入    5判断溢出

1. 低阶转换成高阶，方便保存尾数

2. 尾数进行加减

3. 视尾数结果选择左规或右规

4. 尾数位数太长要舍入，有不同舍位原则

5. 判断的是阶码的溢出

需要多练习
